Download Link: https://assignmentchef.com/product/solved-lab-5
<br>
In this lab you will learn, and reason about, some python idioms, as well as develop some unit testing skills. You may also need to do some reading and review of some Python tools. List comprehensions, zip, and ﬁlter capture logical patterns that are often used by programmers, and provide an occasionally-more-readable and internally-optimized form for them, see Python tips on loops, and Goodger on comprehensions, lter documentation, and Python zip documentation. These forms make a programmer’s intention clear | that they are intending to produce a new list or iterable from an old one. In this lab, you will re-implement some functions written using comprehensions and ﬁlter to use loops instead, and verify that you have consistent implementations using unit tests.Vector and matrix operations Vectors can be represented as python lists of numbers. You may have encountered them, but in any case they support some operations peculiar to themselves. dot product One such operation is the dot-product | a way of multiplying two vectors to get a single number (rather than a list of numbers). Here’s an example, where the symbol &#x1; represents the dot-product operation: [1; 2; 3] &#x1; [4; 5; 6] = (1 &#x2; 4) + (2 &#x2; 5) + (3 &#x2; 6) = 4 + 10 + 18 = 32 Basically, we multiply the corresponding elements of the two vectors together, and then sum those products. Your rst task is to read the de nition of dot prod() in comprehension.py. You may also look over Python tips on loops, tuple unpacking, and zip to see how this solution works. Now, re-implement this function (write your own implementation) in a new le called loop.py without using a list comprehension or zip. Use exactly the same function name, docstring, and parameters, just change the body. Your basic approach will be: 1. create an empty list (if you’re producing a list), or a variable initially set to 0 2. loop over the iterables (lists in this case) provided 3. inside the list, update your list or variable 4. when you’re done, return your list or variable Also, in a new le called tester.py, create new test cases in the TestCase DotProductTester. Increase your con dence that your implementation of dot prod(), as well as the one in comprehension.py, pass appropriate tests. To get an idea of what tests you should consider, review Choosing test cases. You should strive to test one case at a time with small test… methods, rather than lumping all your tests together. You may also review how to set up unit tests. If you’re stuck, talk to your TA. If you’re not stuck, show your TA your work. matrix-vector product Another operation multiplies a matrix M | essentially a list of vectors | times a vector v, resulting in a new vector. The idea is to take the dot-product of each vector in the matrix with the vector you are multiplying 1 it with to yield the corresponding entry in the new vector. An example should make this more concrete (here we indicate the matrix-vector product by &#x2; to distinguish it from the dot-product) [[1; 2]; [3; 4]] &#x2; [5; 6] = [[1; 2] &#x1; [5; 6]; [3; 4] &#x1; [5; 6]] = [17; 39] Notice that we recycle the dot product in order to implement the matrix vector product. Again, your rst task is to read the de nition of matrix vector prod() in comprehension.py. . Then reimplement matrix vector prod() in the le loop.py, using a loop or loops, rather than a comprehension. You should certainly use dot prod() in your implementation. Once you are done, create some new test cases in the TestCase MatrixVectorProductTester in the le tester.py. Increase your con dence that both implementations pass appropriate tests. If you’re stuck, talk to your TA. If you’re not stuck, show your TA your work. Pythagorean triples List comprehensions aren’t just limited to iterating over a single iterable. Try running following example: [(i, j, k) for i in range(3) for j in range(3) for k in range(3)] Pythagorean triples are triples of integers (x; y; z) where x2 + y2 = z2 (representing the sides of special right-angle triangles). These can be discovered analytically (paper and pencil), but why not let a computer do the work? Read over the implementation of pythagorean triples() in comprehension.py. You may rst want to read documentation for lter. Once you’re done, re-implement pythagorean triples() in the le loop.py, using (of course!) neither comprehensions nor the built-in ﬁlter function. Add test methods to the TestCase PythagoreanTripleTester, to increase your con dence that both implementations pass appropriate tests. If you get stuck, call over your TA. If you don’t get stuck, show your completed work to your TA.